# -*- coding: utf-8 -*-
"""

@author: Rowly Mudzhiba

"""
######################## modules #########################################
import numpy as np
import matplotlib.pyplot as plt
import objectives as obj
import pareto
import MODminifunc as func
from Obj_plotter import obj_redrawer
from Point_Generator import Gen
from operator import itemgetter
from scipy import signal
from scipy import linalg
from EulerODE import Euler
from Optimizer import Optimize
from Sys_setup_window import sys_setup
from matplotlib.lines import Line2D
from matplotlib.artist import Artist
from matplotlib.mlab import dist_point_to_segment
from matplotlib.widgets import Button, RadioButtons
from matplotlib.patches import Polygon

###################### Default System parameters #########################
Gp_n = [.125]
Gp_d = [1, 3, 3, 1]
SP = 1.                   # Set Point
tfinal = 100        # simulation period
dt = .1
DT = 0       # Dead time (s)
t = np.arange(0, tfinal, dt)
entries = len(t)

SP_input = 'step'           # Choose Set point input by typing 'step' or 'ramp'
step_time = 0.
ramp_time = 5.
u = func.Step(t, step_time, SP)
SP_info = [SP_input, step_time, ramp_time, SP]


#################### Initializing plots ##################################

# Axis 1 (Kc Vs ti parameters)
fig = plt.figure('MODE v2.13')
ax1 = fig.add_subplot(231)
plt.axis([0, 60, 0, 60])
ax1.plot(None, None)

kc = []
ti = []
td = []
plt.ylabel(r'$K_C$', fontsize='large')
plt.xlabel(r'$\tau_I$', fontsize='large')
index = 0
# Axis 2 ("kc vs td" plot)
ax2 = fig.add_subplot(232, sharey=ax1)
plt.axis([0, 10, 0, 60])
plt.ylabel(r'$K_C$', fontsize='large')
plt.xlabel(r'$\tau_D$', fontsize='large')
polyx, polyy = [], []


# Axis 3 (Objective plot)
ax3 = fig.add_subplot(233)
plt.ylabel('risetime (s)', fontsize='large')
plt.xlabel('overshoot ratio', fontsize='large')

xobj = 'OSR'
yobj = 'RT'
Mop_points = (None, None, None, None, None)
gen_kc_unstable, gen_ti_unstable, gen_td_unstable = None, None, None
gen_kc_offset, gen_ti_offset, gen_td_offset = None, None, None
gen_kc_goodpoints, gen_ti_goodpoints, gen_td_goodpoints = None, None, None
gen_kc_idx, gen_ti_idx, gen_td_idx = None, None, None
por, tr, tpr, ISE, IAE, ITAE = [], [], [], [], [], []
idx, ppor, ptr, pise, piae, pitae = None, None, None, None, None, None


# Axis (Response)
ax4 = fig.add_subplot(212)
plt.ylabel('y', fontsize=12)
plt.xlabel('time (s)', fontsize=12)
plt.axis([0, tfinal, 0, SP * 2])
ax4.text(4, SP, 'Click on the ti vs kc plot to obtain the time response',
         fontsize=16, color='red')
Y = []

SSoffset = None
UNSTABLE = None
goodpoints = None
idx = None


##################################### Plotting functions #################
def redraw_ax1():
    kc1, ti1 = np.array(kc), np.array(ti)
    ax1 = fig.add_subplot(231)
    ax1.cla()
    # line 1-4 :parameters generated by clicking
    # line 5-8 :parameters generated by the button
    line1 = ax1.plot(ti1[SSoffset], kc1[SSoffset], 'g+')
    line2 = ax1.plot(
        ti1[UNSTABLE], kc1[UNSTABLE], 'r+')  # adds ustables points
    line3 = ax1.plot(ti1[goodpoints], kc1[goodpoints], 'wo',
                     picker=5,)  # adds good points
    line4 = ax1.plot(ti1[idx], kc1[idx], 'bo')  # from pareto.data
    line5 = ax1.plot(
        gen_ti_unstable, gen_kc_unstable, 'r+')  # unstable points from Gen
    line6 = ax1.plot(gen_ti_offset, gen_kc_offset, 'g+')
    line7 = ax1.plot(gen_ti_goodpoints, gen_kc_goodpoints, 'wo', picker=5,)
    line8 = ax1.plot(gen_ti_idx, gen_kc_idx, 'bo')
#    plt.figlegend(
#        (line1, line2, line3, line4), ('S/SOffset', 'Unstable', 'Stable points',
#                                       'Pareto points'), 'upper left', borderaxespad=0.5)
    ax1.axis([0, 60, 0, 60])
    plt.ylabel(r'$K_C$', fontsize='large')
    plt.xlabel(r'$\tau_I$', fontsize='large')
def redraw_ax2():
    
    ax2 = fig.add_subplot(232, sharey=ax1)
    ax2.cla()
    plt.axis([0, 10, 0, 60])
    ax2.plot(polyx, polyy, 'ro' ,picker = 3)
    plt.ylabel(r'$K_C$', fontsize='large')
    plt.xlabel(r'$\tau_D$', fontsize='large')
    

def redraw_ax3():

    obj_redrawer(fig, ppor, ptr, pise, piae, pitae, xobj, yobj,
                 Mop_points, por, tr, ISE, IAE, ITAE)


def redraw_ax4():
    ax4 = fig.add_subplot(212)
    ax4.cla()
    ax4.plot(t, Y[-1], tpr[-1], ((por[-1] + 1) * SP), 'ro', linewidth=2.0)
    ax4.axhline(y=SP, color='black', linestyle='--')
    rr = np.linspace(0, SP)
    yy = [tr[-1]] * len(rr)
    ax4.plot(yy, rr, 'k--')
    plt.ylabel('y', fontsize=12)
    plt.xlabel('time (s)', fontsize=12)


#################################### Handles clicks on objective plot(ax3)

#class Pareto_window:
#
#    def __init__(self):
#        self.clickcount = 0
#
#        self.selected, = ax3.plot(None, None, 'o', ms=12, alpha=0.4,
#                                  color='yellow', visible=False)
#        self.correspond, = ax1.plot(None, None, 'o', ms=13, alpha=0.5,
#                                    color='yellow', visible=False)
#
#    def pareto_point(self, event):
#
#        if ax3.contains(event.mouseevent)[0] == True:
#            NW = len(event.ind)
#            if not NW:
#                return True
#            x = event.mouseevent.xdata
#            y = event.mouseevent.ydata
#            radius = np.hypot(x - por[event.ind], y - tr[event.ind])
#            minind = radius.argmin()
#            pstn = event.ind[minind]
#            self.clickcount = pstn
#            self.redraw()
#
#    def redraw(self):
#
#        kc1, ti1 = np.array(kc), np.array(ti)
#        if self.clickcount is None:
#            return
#        pstn = self.clickcount
#        self.selected.set_visible(True)
#        self.selected.set_data(por[pstn], tr[pstn])
#        self.correspond.set_visible(True)
#        self.correspond.set_data(
#            [(ti[goodpoints])[pstn]], [(kc[goodpoints])[pstn]])
#        yt = Y[pstn]
#        ax4 = fig.add_subplot(212)
#        ax4.cla()
#        plt.ylabel('y', fontsize=12)
#        plt.xlabel('time (s)', fontsize=12)
#        ax4.plot(t, yt, tpr[pstn], ((por[pstn] + 1) * SP), 'ro')
#        ax4.axhline(y=SP, color='black', linestyle='--')
#        rr = np.linspace(0, SP)
#        yy = [tr[pstn]] * len(rr)
#        ax4.plot(yy, rr, 'k--')
#        fig.canvas.draw()
#        self.pareto_point()
#
#Pclick = Pareto_window()
#
#fig.canvas.mpl_connect('pick_event', Pclick.pareto_point)

class Parasort:
    def __init__(self):
        self.ax1 = redraw_ax1
        self.ax2 = redraw_ax2
        self.ax3 = redraw_ax3
        self.ax4 = redraw_ax4

    def Stability_evaluation(self, kc_new, tc_new, td_new, index):
        global t, u, entries
        t = np.arange(0, tfinal, dt)
        entries = len(t)
        u = func.Step(t, step_time, SP)
        if len(kc) == index:
            kc.append(kc_new)
            ti.append(tc_new)
            td.append(td_new)
            polyx.append(td_new)
            polyy.append(kc[index])
            Gc_n = [kc[index] * ti[index] * td[index], (kc[index] * ti[index]), kc[index]]
            Gc_d = [ti[index], 0]
            OL_TF_n = np.polymul(Gp_n, Gc_n)
            OL_TF_d = np.polymul(Gc_d, Gp_d)
            CL_TF_n = OL_TF_n
            CL_TF_d = np.polyadd(OL_TF_d, OL_TF_n)
            (A, B, C, D) = signal.tf2ss(OL_TF_n, OL_TF_d)
            (A_CL, B_CL, C_CL, D_CL) = signal.tf2ss(CL_TF_n, CL_TF_d)
            rootsA = np.array(linalg.eigvals(A_CL))
            # Stability check
            if (rootsA.real < 0).all():
                sim_results = Euler(A, B, C, D, t, u, DT)
                                    # Euler intergration is used to generate a
                                    # response
                Y.append(sim_results)
            else:
                show_popup('system is unstable')
                Y.append(np.NaN)
                kc[index] = np.NaN
                ti[index] = np.NaN

        self.Data_distillation(Y, kc, por, ti, tpr, tr, ISE, IAE, ITAE)

    def Data_distillation(self, Y, kc, por, ti, tpr, tr, ISE, IAE, ITAE):
        global SSoffset, UNSTABLE, goodpoints
        global idx, ppor, ptr, pise, piae, pitae

        num = np.shape(Y)[0]

        por1, tpr1 = obj.overshoot(t, Y, num, entries, SP)

        por.append(por1[-1])
        tpr.append(tpr1[-1])
        tr1 = obj.risetime(t, Y, num, entries, SP)
        ISE1 = obj.ISE(t, Y, num, entries, SP)
        ISE.append(ISE1[-1])
        IAE1 = obj.IAE(t, Y, num, entries, SP)
        IAE.append(IAE1[-1])
        ITAE1 = obj.ITAE(t, Y, num, entries, SP)
        ITAE.append(ITAE1[-1])
        tr.append(tr1[-1])
        idx_len = len(kc)
        idx = np.arange(0, idx_len)

        SSoffset = np.isneginf(por)
        UNSTABLE = np.isnan(por)

        # good points are selected
        goodpoints = ~(np.isnan(tr) | np.isnan(
            por) | np.isneginf(por))  # criteria for good points
        tr = np.array(tr)[goodpoints]
        por = np.array(por)[goodpoints]
        tpr = np.array(tpr)[goodpoints]
        ISE = np.array(ISE)[goodpoints]
        IAE = np.array(IAE)[goodpoints]
        ITAE = np.array(ITAE)[goodpoints]
        idx = idx[goodpoints]
        Y = np.array(Y)[goodpoints]

        # Pareto points
        p = pareto.domset([itemgetter(
            1), itemgetter(2)], zip(idx, por, tr, ISE, IAE, ITAE))
        front = p.data
        idx, ppor, ptr, pise, piae, pitae = map(np.array, zip(*front))
        sortidx = np.argsort(ppor)
        ppor = ppor[sortidx]
        ptr = ptr[sortidx]
        pise = pise[sortidx]
        piae = piae[sortidx]
        pitae = pitae[sortidx]
        self.ax1()
        self.ax2()
        self.ax3()
        self.ax4()
        fig.canvas.draw()


    def Stability_evaluation_drag(self,td_new, index):
        global t, u, entries
        t = np.arange(0, tfinal, dt)
        entries = len(t)
        u = func.Step(t, step_time, SP)
        indexi = index
        if len(kc) >= indexi:
            td[indexi] = td_new
            Gc_n = [kc[indexi] * ti[indexi] * td[indexi], (kc[indexi] * ti[indexi]), kc[indexi]]
            Gc_d = [ti[indexi], 0]
            OL_TF_n = np.polymul(Gp_n, Gc_n)
            OL_TF_d = np.polymul(Gc_d, Gp_d)
            CL_TF_n = OL_TF_n
            CL_TF_d = np.polyadd(OL_TF_d, OL_TF_n)
            (A, B, C, D) = signal.tf2ss(OL_TF_n, OL_TF_d)
            (A_CL, B_CL, C_CL, D_CL) = signal.tf2ss(CL_TF_n, CL_TF_d)
            rootsA = np.array(linalg.eigvals(A_CL))
#             Stability check
            if (rootsA.real < 0).all():
                sim_results = Euler(A, B, C, D, t, u, DT)
                                    # Euler intergration is used to generate a
                                    # response
                Y[indexi] = sim_results
            else:
                show_popup('system is unstable')
                Y[indexi] = np.NaN
                kc[indexi] = np.NaN
                ti[indexi] = np.NaN
                td[indexi] = np.NaN
        self.Data_distillation2(Y, kc, por, ti, tpr, tr, ISE, IAE, ITAE, indexi)
#
    def Data_distillation2(self, Y, kc, por, ti, tpr, tr, ISE, IAE, ITAE,indexi):
        global SSoffset, UNSTABLE, goodpoints
        global idx, ppor, ptr, pise, piae, pitae
        num = np.shape(Y)[0]

        por1, tpr1 = obj.overshoot(t, Y, num, entries, SP)
        por[indexi] = por1[indexi]
        tpr[indexi] = tpr1[indexi]
        tr1 = obj.risetime(t, Y, num, entries, SP)
        ISE1 = obj.ISE(t, Y, num, entries, SP)
        ISE[indexi] = ISE1[indexi]
        IAE1 = obj.IAE(t, Y, num, entries, SP)
        IAE[indexi] = IAE1[indexi]
        ITAE1 = obj.ITAE(t, Y, num, entries, SP)
        ITAE[indexi] = ITAE1[indexi]
        tr[indexi] = tr1[indexi]
        idx_len = len(kc)
        idx = np.arange(0, idx_len)

        SSoffset = np.isneginf(por)
        UNSTABLE = np.isnan(por)

        # good points are selected
        goodpoints = ~(np.isnan(tr) | np.isnan(
            por) | np.isneginf(por))  # criteria for good points
        tr = np.array(tr)[goodpoints]
        por = np.array(por)[goodpoints]
        tpr = np.array(tpr)[goodpoints]
        ISE = np.array(ISE)[goodpoints]
        IAE = np.array(IAE)[goodpoints]
        ITAE = np.array(ITAE)[goodpoints]
        
        idx = np.array(idx)[goodpoints]
        Y = np.array(Y)[goodpoints]
#
#       Pareto points
        p = pareto.domset([itemgetter(
            1), itemgetter(2)], zip(idx, por, tr, ISE, IAE, ITAE))
        front = p.data
        idx, ppor, ptr, pise, piae, pitae = map(np.array, zip(*front))
        sortidx = np.argsort(ppor)
        ppor = ppor[sortidx]
        ptr = ptr[sortidx]
        pise = pise[sortidx]
        piae = piae[sortidx]
        pitae = pitae[sortidx]
        self.ax1()
        self.ax2()
        self.ax3()
        
        ax4 = fig.add_subplot(212)
        ax4.cla()
        ax4.plot(t, Y[indexi], tpr[indexi], ((por[indexi] + 1) * SP), 'ro', linewidth=2.0)
        ax4.axhline(y=SP, color='black', linestyle='--')
        rr = np.linspace(0, SP)
        yy = [tr[indexi]] * len(rr)
        ax4.plot(yy, rr, 'k--')
        plt.ylabel('y', fontsize=12)
        plt.xlabel('time (s)', fontsize=12)

        fig.canvas.draw()

############################ Draws and enables dragging points on 'kc vs t


class PolygonInteractor:



    def __init__(self):
        x, y = polyx, polyy
        self.line = ax2.plot(x,y,'ro',picker = 3)
        self._ind = None 

    def point_pick(self,event):
        if ax2.contains(event.mouseevent)[0] == True:
            x = event.mouseevent.xdata
            y = event.mouseevent.ydata
            r2 = np.hypot(x-(polyx)[event.ind], y-(polyy)[event.ind])
            m2 = r2.argmin()
            self._ind = event.ind[m2]
            redraw_ax2()
        return
    def button_press_callback(self, event):
        
        if ax2.contains(event)[0] == True:
            'whenever a mouse button is pressed'
            if event.inaxes == None:
                return
            if event.button != 1:
                return

    def button_release_callback(self, event):
        if ax2.contains(event)[0] == True:
            'whenever a mouse button is released'
            if event.button != 1:
                return   
            td_new =  polyx[self._ind]
            Parasort().Stability_evaluation_drag(td_new, self._ind)
#            redraw_ax2()

    def motion_notify_callback(self, event):
        if ax2.contains(event)[0] == True:
            'on mouse movement'
            if self._ind is None:
                return
            if event.inaxes is None:
                return
            if event.button != 1:
                return

            x, y = event.xdata, event.ydata
            polyx[self._ind], polyy[self._ind] = x, kc[self._ind]
            td[self._ind] = event.xdata
            redraw_ax2()
            fig.canvas.draw()


################################ Handles clicking on the 'kc and ti' plot(


class Parameter_window:
    def __init__(self):
        self.ax1 = redraw_ax1
        self.ax2 = redraw_ax2
        self.ax3 = redraw_ax3
        self.ax4 = redraw_ax4
        self.fig = fig
        self.index = 0
        
    def select(self, event):
        if ax1.contains(event)[0] == True:
            # Clearing all plots
            if ax1.contains(event)[0] == True:
                kc_new, tc_new, td_new = event.ydata, event.xdata, 0
                index = self.index
                
                Parasort().Stability_evaluation(kc_new, tc_new, td_new, index)
                self.index = self.index +1


click = Parameter_window()
fig.canvas.mpl_connect('button_press_event', click.select)
P = PolygonInteractor()
fig.canvas.mpl_connect('pick_event', P.point_pick)
fig.canvas.mpl_connect('button_press_event', P.button_press_callback)
fig.canvas.mpl_connect('button_release_event', P.button_release_callback)
fig.canvas.mpl_connect('motion_notify_event', P.motion_notify_callback)

class kc_td_interact():  
        def __init__(self):
              self.l2 = 0
              self.selectedtc, = ax2.plot(None, None,'o',ms = 13,alpha = 0.5,color = 'orange',visible= False)
              self.correspondtc, = ax1.plot(None, None, 'o', ms=12, alpha=0.4,
                                          color='orange', visible=False)
        def onpick(self,event):
           if ax2.contains(event.mouseevent)[0] == True:
              NW2 = len(event.ind)
              if not NW2: return True
              x = event.mouseevent.xdata
              y = event.mouseevent.ydata
              r2 = np.hypot(x-(polyx)[event.ind], y-(polyy)[event.ind])
              m2 = r2.argmin()
              p2 = event.ind[m2]
              self.l2 = p2
              self.update()
        def update(self):
              if self.l2 is None: return
              p2 = self.l2
              self.selectedtc.set_visible(True)
              self.selectedtc.set_data([(np.array(polyx))[p2]],[(np.array(polyy))[p2]])
              self.correspondtc.set_visible(True)
              self.correspondtc.set_data((np.array(ti)[goodpoints])[p2], (np.array(kc)[goodpoints])[p2])
              yt = Y[p2]
              ax4 = fig.add_subplot(212)
              ax4.cla()
              plt.ylabel('y')
              plt.xlabel('time (s)')
              ax4.plot(t,yt,tpr[p2],((por[p2] + 1)*SP),'ro',linewidth = 2.0)
              ax4.axhline(y=SP,color ='black',linestyle ='--')
              rr = np.linspace(0,SP)
              yy = [tr[p2]]*len(rr)
              ax4.plot(yy,rr,'k--')
                 
              fig.canvas.draw()
              return True
          
tim = kc_td_interact()
fig.canvas.mpl_connect('pick_event', tim.onpick)

class pareto_interact():
    def __init__(self):
        self.lastind = 0
        
        self.selected,  = ax3.plot(None, None, 'o', ms=12, alpha=0.4,
                                      color='yellow', visible=False)
        self.correspond, = ax1.plot(None,None,'o',ms = 13,alpha = 0.5,color = 'yellow',visible= False)
        self.correspond2, = ax2.plot(None,None,'o',ms = 13,alpha = 0.5,color = 'yellow',visible= False)
    def onpick(self,event):
        if ax3.contains(event.mouseevent)[0] == True:
   
            NW = len(event.ind)
            
            if not NW: return True
            x = event.mouseevent.xdata
            y = event.mouseevent.ydata
            radius = np.hypot(x-por[event.ind], y-tr[event.ind])
            minind = radius.argmin()
            pstn = event.ind[minind]
            self.lastind = pstn
            self.update()
   
    def update(self):
        if self.lastind is None: return
        pstn = self.lastind
        self.selected.set_visible(True)
        self.selected.set_data(por[pstn], tr[pstn])
        self.correspond.set_visible(True)
        self.correspond.set_data((np.array(ti)[goodpoints])[pstn], (np.array(kc)[goodpoints])[pstn])
        self.correspond2.set_visible(True)
        self.correspond2.set_data([(np.array(polyx))[pstn]],[(np.array(polyy))[pstn]])
        yt = Y[pstn]
        ax4 = fig.add_subplot(212)
        ax4.cla()
        plt.ylabel('y')
        plt.xlabel('time (s)')
        ax4.plot(t,yt,tpr[pstn],((por[pstn] + 1)*SP),'ro',linewidth = 2.0)
        ax4.axhline(y=SP,color ='black',linestyle ='--')
        rr = np.linspace(0,SP)
        yy = [tr[pstn]]*len(rr)
        ax4.plot(yy,rr,'k--')
         
        fig.canvas.draw()
        return True
        
time = pareto_interact()
fig.canvas.mpl_connect('pick_event', time.onpick)
######################################### Buttons ######################################################
# System change button


def step_window(self):
    global GP_n, Gp_d, tfinal, dt, DT, SP, step_time, ramp_time, SP_input
    GP_n, Gp_d, tfinal, dt, DT, SP, step_time, ramp_time, SP_input = sys_setup(
    )

System = plt.axes([0.25, .92, 0.1, 0.05])
sysbutton = Button(System, 'System Setup')
sysbutton.on_clicked(step_window)

# Initial point generation

def Point_gen(self):
    global gen_kc_unstable, gen_ti_unstable, gen_td_unstable
    global gen_kc_offset, gen_ti_offset, gen_td_offset
    global gen_kc_goodpoints, gen_ti_goodpoints, gen_td_goodpoints
    global gen_kc_idx, gen_ti_idx, gen_td_idx

    gen_kc_unstable, gen_ti_unstable, gen_td_unstable, gen_kc_offset, gen_ti_offset, gen_td_offset, gen_kc_goodpoints, gen_ti_goodpoints, gen_td_goodpoints, gen_kc_idx, gen_ti_idx, gen_td_idx = Gen(
        Gp_n, Gp_d, SP, tfinal, dt, DT)
    redraw_ax1()
    fig.canvas.draw()


Ppoints = plt.axes([0.125, .92, 0.1, 0.05])
pointbutton = Button(Ppoints, 'Generate')
pointbutton.on_clicked(Point_gen)

# Mopsocd Button


def Opt(self):
    global Mop_points, Mop_por, Mop_tr, Mop_ISE, Mop_IAE, Mop_ITAE
    Mop_points = Optimize(tfinal, dt, Gp_n, Gp_d, SP, DT, u)
    redraw_ax3()
    fig.canvas.draw()

Mopsocd = plt.axes([0.75, .92, 0.1, 0.05])
Mop_button = Button(Mopsocd, 'Mopso-cd')
Mop_button.on_clicked(Opt)


# Objective radio buttons
   # Y axis
rax = plt.axes([0.91, 0.75, 0.07, 0.15])
radio = RadioButtons(rax, ('RT', 'OSR', 'ISE', 'IAE', 'ITAE'))


def colorfunc(label):
    global yobj
    yobj = label
    ax3.cla()
    obj_redrawer(fig, ppor, ptr, pise, piae, pitae, xobj, yobj,
                 Mop_points, por, tr, ISE, IAE, ITAE)
    plt.draw()

radio.on_clicked(colorfunc)

  # X axis
rax2 = plt.axes([0.91, 0.55, 0.07, 0.15])
radio2 = RadioButtons(rax2, ('OSR', 'ISE', 'IAE', 'ITAE', 'RT'))


def colorfunc2(label):
    global xobj
    xobj = label
    ax3.cla()
    obj_redrawer(fig, ppor, ptr, pise, piae, pitae, xobj, yobj,
                 Mop_points, por, tr, ISE, IAE, ITAE)
    plt.draw()
radio2.on_clicked(colorfunc2)

plt.show()
