# -*- coding: utf-8 -*-
"""

@author: Rowly Mudzhiba

"""
######################## modules #########################################
import numpy as np
import matplotlib.pyplot as plt
import objectives as obj
import pareto
import MODminifunc as func
import tkFont
import Tkinter as tk
import platform

from Obj_plotter import obj_redrawer
from operator import itemgetter
from scipy import signal
from scipy import linalg
from EulerODE import Euler
from Optimizer import Optimize
from Tuners import*
from matplotlib.widgets import Button, RadioButtons


###################### Default System parameters #########################

Gp_n = [0.125]
Gp_d = [1, 3, 3, 1]
SP = 1.
tfinal = 100      
dt = .1
DT = 0  #dead time
t = np.arange(0, tfinal, dt)
entries = len(t)

SP_input = 'Step'
step_time = 0.
ramp_time = .5
num_of_gens = [0]

#################### Initializing plots ################################## 
'''
A lot of variables are empty, set as None or Zero.
These variables a used when the program starts up
''' 
# Axis 1 (Kc Vs ti parameters)
fig = plt.figure('MODE v2.13')
ax1 = fig.add_subplot(231)
plt.axis([0, 60, 0, 60])
ax1.plot(None, None)

kc = []
ti = []
td = []

plt.ylabel(r'$K_C$', fontsize='large')
plt.xlabel(r'$\tau_I$', fontsize='large')
index = 0

# Axis 2 ("kc vs td" plot)
ax2 = fig.add_subplot(232, sharey=ax1)
polyx, polyy = [], []
plt.axis([0, 10, 0, 60])
plt.ylabel(r'$K_C$', fontsize='large')
plt.xlabel(r'$\tau_D$', fontsize='large')



# Axis 3 (Objective space)
ax3 = fig.add_subplot(233)
plt.ylabel('risetime (s)', fontsize='large')
plt.xlabel('overshoot ratio', fontsize='large')

xobj = 'OSR'
yobj = 'RT'

Mop_points = [None, None, None, None, None]
gen_kc_unstable, gen_ti_unstable, gen_td_unstable = None, None, None
gen_kc_offset, gen_ti_offset, gen_td_offset = None, None, None
gen_kc_goodpoints, gen_ti_goodpoints, gen_td_goodpoints = None, None, None
gen_kc_idx, gen_ti_idx, gen_td_idx = None, None, None
gen_ppor, gen_ptr, gen_pise, gen_piae, gen_pitae = None, None, None, None, None
gen_por, gen_tr, gen_ise, gen_iae, gen_itae = None, None, None, None, None
por, tr, tpr, ISE, IAE, ITAE = [], [], [], [], [], []
idx, ppor, ptr, pise, piae, pitae = [], [], [], [], [], []
pickerind = None

# Axis 4 (Response Curve)
ax4 = fig.add_subplot(212)
plt.ylabel('y', fontsize=12)
plt.xlabel('time (s)', fontsize=12)
plt.axis([0, tfinal, 0, SP * 2])
ax4.text(4, SP, 'Click on the ti vs kc plot to obtain the time response',
         fontsize=16, color='red')
Y = []
SSoffset = []
UNSTABLE = []
goodpoints = []
idx = []


##################################### Plotting functions #################
'''
The redraw functions are used to update the plots when a
mouse event occurs

'''

def redraw_ax1():
    kc1, ti1 = np.array(kc), np.array(ti)
    ax1 = fig.add_subplot(231)
    ax1.cla() # Clears the plot area

    # line 1-4 :parameters generated by clicking
    # line 5-8 :parameters generated by the button
    line1 = ax1.plot(ti1[SSoffset], kc1[SSoffset], 'g+', label = "Offset")
    line2 = ax1.plot(ti1[UNSTABLE], kc1[UNSTABLE], 'r+') 
    line3 = ax1.plot(ti1[goodpoints], kc1[goodpoints], 'wo', label = "stable")
    line4 = ax1.plot(ti1[idx], kc1[idx], 'go')
    
    line5 = ax1.plot(gen_ti_unstable, gen_kc_unstable, 'r+',label = "unstable") 
    line6 = ax1.plot(gen_ti_offset, gen_kc_offset, 'g+')
    line7 = ax1.plot(gen_ti_goodpoints, gen_kc_goodpoints, 'wo')
    line8 = ax1.plot(gen_ti_idx, gen_kc_idx, 'bo')

    ax1.axis([0, 60, 0, 60])
    plt.ylabel(r'$K_C$', fontsize='large')
    plt.xlabel(r'$\tau_I$', fontsize='large')
    plt.legend(bbox_to_anchor=(0,1), loc= 5, borderaxespad=3)
def redraw_ax2():
    global line9, line10
    ax2 = fig.add_subplot(232, sharey=ax1)
    ax2.cla()
    plt.axis([0, 10, 0, 60])
    line9, = ax2.plot(gen_td_idx, gen_kc_idx, 'bo',picker = 5,)
    line10, = ax2.plot(polyx, polyy, 'go',picker = 5,)
    
    plt.ylabel(r'$K_C$', fontsize='large')
    plt.xlabel(r'$\tau_D$', fontsize='large')
    

def redraw_ax3():
    global line11, line12, line13
    line11, line12, line13 = obj_redrawer(fig, ppor, ptr, pise, piae, pitae, xobj, yobj,
                 Mop_points, por, tr, ISE, IAE, ITAE, gen_ppor,
                 gen_ptr, gen_pise, gen_piae, gen_pitae, gen_por,
                 gen_tr, gen_ise, gen_iae, gen_itae)


def redraw_ax4():

    ax4 = fig.add_subplot(212)
    ax4.cla()
    ax4.plot(t, Y[-1], tpr[-1], ((por[-1] + 1) * SP), 'ro', linewidth=2.0)
    ax4.axhline(y=SP, color='black', linestyle='--')
    rr = np.linspace(0, SP)
    yy = [tr[-1]] * len(rr)
    ax4.plot(yy, rr, 'k--')
    plt.ylabel('y', fontsize=12)
    plt.xlabel('time (s)', fontsize=12)

############################### Event handling Classes ########################



class Parasort:
    '''
    Parasort is used to sort out the order controller parameter
    points and organise the controller parameter points. 
    This class is called when the user clicks or drags a point .
    '''
    def __init__(self):
        self.ax1 = redraw_ax1
        self.ax2 = redraw_ax2
        self.ax3 = redraw_ax3
        self.ax4 = redraw_ax4

    def Stability_evaluation(self, kc_new, tc_new, td_new, index):
        global t, entries, u
        
        # simulation time is redefined, incase the was changes of Sim. parameters
        t = np.arange(0, tfinal, dt)
        entries = len(t)
        
        if SP_input == 'Step':
            u = func.Step(t, step_time, SP)
        else:
            u = func.Ramp(t, ramp_time, SP)
           
        if len(kc) == index: 
            # when a point is clicked new parameters are added to the relative list
            kc.append(kc_new)
            ti.append(tc_new)
            td.append(td_new)
            
            # The Controller num and den are calculated for the set of parameters
            Gc_n = [kc[index] * ti[index] * td[index], (kc[index] * ti[index]), kc[index]]
            Gc_d = [ti[index], 0]
            
            # Open-loop and closed-loop transfer functions are calculated
            OL_TF_n = np.polymul(Gp_n, Gc_n)
            OL_TF_d = np.polymul(Gc_d, Gp_d)
            CL_TF_n = OL_TF_n
            CL_TF_d = np.polyadd(OL_TF_d, OL_TF_n)
            
            #Both TFs are converted to state space
            #The OL-TF is used for simuation while CL-TF is used to check for stability            
            (A, B, C, D) = signal.tf2ss(OL_TF_n, OL_TF_d)
            (A_CL, B_CL, C_CL, D_CL) = signal.tf2ss(CL_TF_n, CL_TF_d)        
            rootsA = np.array(linalg.eigvals(A_CL))
            
            # Stability check
            if (rootsA.real < 0).all():
                # Euler intergration(external module) 
                sim_results = Euler(A, B, C, D, t, u, DT)
                Y.append(sim_results)
                
                # polyx,polyy are lists that used to plot point on the "kc vs td" plot
                # polyy has all the kc the were click
                # ployx is a list of all the new_td = 0 or td that was chaged by dragging
                # eg. ployy = [12, 4, 7], ployx = [0, 3.4, 0]
                # points are appended only if the system is stable
                polyx.append(td_new)
                polyy.append(kc[index])
                
            else:
                del Y[index]
                del kc[index]
                del ti[index]
                del td[index]
                

        self.Data_distillation(Y, kc, por, ti, tpr, tr, ISE, IAE, ITAE)

    def Data_distillation(self, Y, kc, por, ti, tpr, tr, ISE, IAE, ITAE):
        global SSoffset, UNSTABLE, goodpoints
        global idx, ppor, ptr, pise, piae, pitae
        
        # objectives are evaluated and grouped.
        # por = overshoot ratio, tr  = rise time 
        num = np.shape(Y)[0]
        por1, tpr1 = obj.overshoot(t, Y, num, entries, SP)
        por.append(por1[-1])
        tpr.append(tpr1[-1])
        tr1 = obj.risetime(t, Y, num, entries, SP)
        ISE1 = obj.ISE(t, Y, num, entries, SP)
        ISE.append(ISE1[-1])
        IAE1 = obj.IAE(t, Y, num, entries, SP)
        IAE.append(IAE1[-1])
        ITAE1 = obj.ITAE(t, Y, num, entries, SP)
        ITAE.append(ITAE1[-1])
        tr.append(tr1[-1])
        if (np.isnan(tr[-1]) | np.isnan(por[-1]) | np.isneginf(por[-1])) == True:
            SSoffset = np.isneginf(por)
            UNSTABLE= np.isnan(por)
            goodpoints = ~(np.isnan(tr) | np.isnan(por) | np.isneginf(por))
            idx_len = len(kc)
            idx = np.arange(0, idx_len)
            idx = np.array(idx)[goodpoints]
        else:
            idx_len = len(kc)
            idx = np.arange(0, idx_len)
    
            # good points are selected
            goodpoints = ~(np.isnan(tr) | np.isnan(por) | np.isneginf(por)) 
            tr = np.array(tr)[goodpoints]
            por = np.array(por)[goodpoints]
            tpr = np.array(tpr)[goodpoints]
            ISE = np.array(ISE)[goodpoints]
            IAE = np.array(IAE)[goodpoints]
            ITAE = np.array(ITAE)[goodpoints]
            idx = np.array(idx)[goodpoints]
            Y = np.array(Y)[goodpoints]
            
            # All the objective are parsed as arguments to the pareto.domset  
            p = pareto.domset(map(itemgetter, range(1, 6)), zip(idx, por, tr, ISE, IAE, ITAE))
            front = p.data
            idx, ppor, ptr, pise, piae, pitae = map(np.array, zip(*front))
            sortidx = np.argsort(ppor)
            ppor = ppor[sortidx]
            ptr = ptr[sortidx]
            pise = pise[sortidx]
            piae = piae[sortidx]
            pitae = pitae[sortidx]

        
        
        # All the plots are updated with new data
        self.ax1()
        self.ax2()
        self.ax3()
        ax4 = fig.add_subplot(212)
        ax4.cla()
        ax4.plot(t, Y[-1], 'g', tpr[-1], ((por[-1] + 1) * SP), 'ro', linewidth=2.0)
        ax4.axhline(y=SP, color='black', linestyle='--')
        rr = np.linspace(0, SP)
        yy = [tr[-1]] * len(rr)
        ax4.plot(yy, rr, 'k--')
        plt.ylabel('y', fontsize=12)
        plt.xlabel('time (s)', fontsize=12)
        fig.canvas.draw()


    def Stability_evaluation_drag(self,td_new, index):
        # index is used to identify the points being dragged
        # So instead of appending data, data is being re-assigned
        indexi = index
        if len(kc) >= indexi:
            td[indexi] = td_new
            Gc_n = [kc[indexi] * ti[indexi] * td[indexi], (kc[indexi] * ti[indexi]), kc[indexi]]
            Gc_d = [ti[indexi], 0]
            OL_TF_n = np.polymul(Gp_n, Gc_n)
            OL_TF_d = np.polymul(Gc_d, Gp_d)
            CL_TF_n = OL_TF_n
            CL_TF_d = np.polyadd(OL_TF_d, OL_TF_n)
            (A, B, C, D) = signal.tf2ss(OL_TF_n, OL_TF_d)
            (A_CL, B_CL, C_CL, D_CL) = signal.tf2ss(CL_TF_n, CL_TF_d)
            rootsA = np.array(linalg.eigvals(A_CL))

            if (rootsA.real < 0).all():
                sim_results = Euler(A, B, C, D, t, u, DT)
                Y[indexi] = sim_results
            else:
                show_popup('system is unstable')
                Y[indexi] = np.NaN
                kc[indexi] = np.NaN
                ti[indexi] = np.NaN
                td[indexi] = np.NaN
        self.Data_distillation2(Y, kc, por, ti, tpr, tr, ISE, IAE, ITAE, indexi)

    def Data_distillation2(self, Y, kc, por, ti, tpr, tr, ISE, IAE, ITAE,indexi):
        global SSoffset, UNSTABLE, goodpoints
        global idx, ppor, ptr, pise, piae, pitae
        num = np.shape(Y)[0]
        por1, tpr1 = obj.overshoot(t, Y, num, entries, SP)
        tr1 = obj.risetime(t, Y, num, entries, SP)
        por[indexi] = float(por1[indexi])
        tpr[indexi] = float(tpr1[indexi])
        ISE1 = obj.ISE(t, Y, num, entries, SP)
        ISE[indexi] = float(ISE1[indexi])
        IAE1 = obj.IAE(t, Y, num, entries, SP)
        IAE[indexi] = float(IAE1[indexi])
        ITAE1 = obj.ITAE(t, Y, num, entries, SP)
        ITAE[indexi] = float(ITAE1[indexi])
        tr[indexi] = float(tr1[indexi])
        
        if (np.isnan(tr[indexi] ) | np.isnan(por[indexi] ) | np.isneginf(por[indexi])) == True:
            SSoffset = np.isneginf(por)
            UNSTABLE= np.isnan(por)
            goodpoints = ~(np.isnan(tr) | np.isnan(por) | np.isneginf(por))
            idx_len = len(kc)
            idx = np.arange(0, idx_len)
            idx = np.array(idx)[goodpoints]
        else:

            idx_len = len(kc)
            idx = np.arange(0, idx_len)
            goodpoints = ~(np.isnan(tr) | np.isnan(por) | np.isneginf(por))
  
            tr = np.array(tr)[goodpoints]
            por = np.array(por)[goodpoints]
            tpr = np.array(tpr)[goodpoints]
            ISE = np.array(ISE)[goodpoints]
            IAE = np.array(IAE)[goodpoints]
            ITAE = np.array(ITAE)[goodpoints]

            idx = np.array(idx)[goodpoints]
            p = pareto.domset(map(itemgetter, range(1, 6)), zip(idx, por, tr, ISE, IAE, ITAE))
            front = p.data
            idx, ppor, ptr, pise, piae, pitae = map(np.array, zip(*front))
            sortidx = np.argsort(ppor)
            ppor = ppor[sortidx]
            ptr = ptr[sortidx]
            pise = pise[sortidx]
            piae = piae[sortidx]
            pitae = pitae[sortidx]
        
        self.ax1()
        self.ax2()
        self.ax3()
        
        ax4 = fig.add_subplot(212)
        ax4.cla()
        ax4.plot(t, (Y[indexi]), 'g', tpr[indexi], ((por[indexi] + 1) * SP), 'ro', linewidth=2.0)
        ax4.axhline(y=SP, color='black', linestyle='--')
        rr = np.linspace(0, SP)
        yy = [tr[indexi]] * len(rr)
        ax4.plot(yy, rr, 'k--')
        plt.ylabel('y', fontsize=12)
        plt.xlabel('time (s)', fontsize=12)

        fig.canvas.draw()

############### Draws and enables dragging points on 'kc vs td' #################

class PolygonInteractor:
    '''
    PolygonInteractor is a class copied from "polygon editor".
    The original class can be found on http://matplotlib.org/examples/event_handling/poly_editor.html
    The class was later modified to be compatible with MODE v2.13
    '''

    def __init__(self):
        x, y = polyx, polyy
        self.line = ax2.plot(x,y,'go',picker = 3)
        line10, = self.line
        
        self._ind = index


    def point_pick(self,event):
        # The function first checks if the mouse event
        # is on the right plot area.
        if ax2.contains(event.mouseevent)[0] == True: 

            self._ind = event.ind

        return
    def button_press_callback(self, event):
        
        if ax2.contains(event)[0] == True:
            # whenever a mouse button is pressed'
            if event.inaxes == None:
                return
            if event.button != 1:
                return
  

    def button_release_callback(self, event):
        if ax2.contains(event)[0] == True:
            # whenever a mouse button is released

            if event.button != 1:
                return
            if pickerind == None:
                return 
                
            td_new =  polyx[self._ind]
            
            # After a point is dragged and the button is released
            # a new objectives and response curve is generated
            Parasort().Stability_evaluation_drag(td_new, self._ind)
            return

    def motion_notify_callback(self, event):
        if ax2.contains(event)[0] == True:
            # on mouse movement the function is actived
            if self._ind is None:
                return
            if event.inaxes is None:
                return
            if event.button != 1:
                return
            if pickerind == None:
                return

            x, y = event.xdata, event.ydata
            self._ind = pickerind
            polyx[self._ind], polyy[self._ind] = x, kc[self._ind]
            td[self._ind] = event.xdata
            redraw_ax2()
            fig.canvas.draw()
            return
            
P = PolygonInteractor()
fig.canvas.mpl_connect('pick_event', P.point_pick)
fig.canvas.mpl_connect('button_press_event', P.button_press_callback)
fig.canvas.mpl_connect('button_release_event', P.button_release_callback)
fig.canvas.mpl_connect('motion_notify_event', P.motion_notify_callback)

################## Handles clicking on the 'kc and ti' ######################


class Parameter_window:
    def __init__(self):
        self.ax1 = redraw_ax1
        self.ax2 = redraw_ax2
        self.ax3 = redraw_ax3
        self.ax4 = redraw_ax4
        self.fig = fig
        self.index = 0
        
    def select(self, event):
        if ax1.contains(event)[0] == True:
            # Clearing all plots
            if ax1.contains(event)[0] == True:
                kc_new, tc_new, td_new = event.ydata, event.xdata, 0
                index = self.index
                Parasort().Stability_evaluation(kc_new, tc_new, td_new, index)
                self.index = self.index +1


click = Parameter_window()
fig.canvas.mpl_connect('button_press_event', click.select)

################# Handles picking of points on 'kc vs td' #################
class kc_td_interact():  
        def __init__(self):
              self.l2 = 0

        def onpick(self,event):
           if ax2.contains(event.mouseevent)[0] == True:
              global pickerind
              NW2 = len(event.ind)
              if not NW2: return True
              x = event.mouseevent.xdata
              y = event.mouseevent.ydata
              
              # line9 is the generated parameters and line10 is the picked parameters
              if event.artist == line9:
                  pickerind = None
                  
                  r2 = np.hypot(x-(gen_td_idx)[event.ind], y-(gen_kc_idx)[event.ind])
                  m2 = r2.argmin()
                  p2 = event.ind[m2]
    
                  self.l2 = p2
                  self.update()
              else:
                  NW2 = len(event.ind)
                  if not NW2: return True

                  r2 = np.hypot(x-(polyx)[event.ind], y-(polyy)[event.ind])
    
                  m2 = r2.argmin()
                  p2 = event.ind[m2]
    
                  self.l2 = p2
                  pickerind = p2
                  self.update2()

        def update(self):
              if self.l2 is None: return
              p2 = self.l2
              ax1.cla()
              ax2.cla()
              ax3.cla()
              redraw_ax1()
              redraw_ax2()
              redraw_ax3()
              # A yellow point is plotted to identify the corresponding point
              ax1.plot(gen_ti_idx[p2], gen_kc_idx[p2],'o',ms = 13,alpha = 0.5,color = 'yellow')
              ax3.plot(gen_ppor[p2], gen_ptr[p2],'o',ms = 13,alpha = 0.5,color = 'yellow')
              yt = Ygen[p2]
              ax4 = fig.add_subplot(212)
              ax4.cla()
              plt.ylabel('y')
              plt.xlabel('time (s)')
              ax4.plot(t,yt,'b',linewidth = 2.0)
              ax4.axhline(y=SP,color ='black',linestyle ='--')

                 
              fig.canvas.draw()
              return True
              
        def update2(self):
              
              if self.l2 is None: return
              p2 = self.l2
              ax1.plot(ti[p2],kc[p2],'o',ms = 13,alpha = 0.5,color = 'yellow')
              yt = Y[p2]
              ax4 = fig.add_subplot(212)
              ax4.cla()
              plt.ylabel('y')
              plt.xlabel('time (s)')
              ax4.plot(t,yt,'g',tpr[p2],((por[p2] + 1)*SP),'ro',linewidth = 2.0)
              ax4.axhline(y=SP,color ='black',linestyle ='--')
              rr = np.linspace(0,SP)
              yy = [tr[p2]]*len(rr)
              ax4.plot(yy,rr,'k--')
                 
              fig.canvas.draw()
              return True   
              
tim = kc_td_interact()
fig.canvas.mpl_connect('pick_event', tim.onpick)

################# Handles picking of points on objective space #################
class pareto_interact():

    def onpick(self,event):
        
        if ax3.contains(event.mouseevent)[0] == True:
            NW = len(event.ind)   
            if not NW: return True
            x = event.mouseevent.xdata
            y = event.mouseevent.ydata
            
            # line13 is the generated parameters and line12 is the picked parameters 
            if event.artist == line12:
                radius = np.hypot(x-por[event.ind], y-tr[event.ind])
                minind = radius.argmin()
                pstn = event.ind[minind]
                self.lastind = pstn
                self.update()
                
            elif event.artist == line13:
                radius = np.hypot(x-gen_ppor[event.ind], y-gen_ptr[event.ind])
                minind = radius.argmin()
                pstn = event.ind[minind]
                self.lastind = pstn
                self.update2()
   
    def update(self):
        if self.lastind is None: return
        pstn = self.lastind
        ti1 = np.array(ti)[idx]
        kc1 = np.array(kc)[idx]
        ax1.cla()
        ax2.cla()
        ax3.cla()
        redraw_ax1()
        redraw_ax2()
        redraw_ax3()
        # A yellow point is plotted to identify the corresponding point
        ax1.plot(ti1[pstn],kc1[pstn],'o',ms = 13,alpha = 0.5,color = 'yellow')
        ax2.plot([(np.array(polyx))[pstn]],[(np.array(polyy))[pstn]],'o',ms = 13,alpha = 0.5,color = 'yellow')
        ax3.plot(ppor[pstn], ptr[pstn],'o',ms = 13,alpha = 0.5,color = 'yellow')
        yt = (np.array(Y)[idx])[pstn]
        ax4 = fig.add_subplot(212)
        ax4.cla()
        plt.ylabel('y')
        plt.xlabel('time (s)')
        ax4.plot(t,yt,'g',tpr[pstn],((por[pstn] + 1)*SP),'ro',linewidth = 2.0)
        ax4.axhline(y=SP,color ='black',linestyle ='--')
        rr = np.linspace(0,SP)
        yy = [tr[pstn]]*len(rr)
        ax4.plot(yy,rr,'k--')
         
        fig.canvas.draw()
        return True
        
    def update2(self):
        if self.lastind is None: return
        pstn = self.lastind
        ax1.cla()
        ax2.cla()
        ax3.cla()
        redraw_ax1()
        redraw_ax2()
        redraw_ax3()
        
        ax1.plot(gen_ti_idx[pstn],gen_kc_idx[pstn],'o',ms = 13,alpha = 0.5,color = 'yellow')
        ax2.plot(gen_td_idx[pstn],gen_kc_idx[pstn],'o',ms = 13,alpha = 0.5,color = 'yellow')
        ax3.plot(gen_ppor[pstn], gen_ptr[pstn],'o',ms = 13,alpha = 0.5,color = 'yellow')
        yt = Ygen[pstn]
        ax4 = fig.add_subplot(212)
        ax4.cla()
        plt.ylabel('y')
        plt.xlabel('time (s)')
        ax4.plot(t,yt,'b',linewidth = 2.0)
        ax4.axhline(y=SP,color ='black',linestyle ='--')
         
        fig.canvas.draw()
        return True        
        
time = pareto_interact()
fig.canvas.mpl_connect('pick_event', time.onpick)

class Point_generation():

    ''' Point_generation has the same structure as Thirdorder_RTT (MODE v2.12 (2012 MODE)) coded
        by Nokukhanya Khwela and modified by Rowly Mudzhiba.
        
    '''       
    def plotter(self, kc,ti,td,x,num,entries,t,tfinal,dt,SP):
        
        global gen_kc_unstable, gen_ti_unstable, gen_td_unstable
        global gen_kc_offset, gen_ti_offset, gen_td_offset
        global gen_kc_goodpoints, gen_ti_goodpoints, gen_td_goodpoints
        global gen_kc_idx, gen_ti_idx, gen_td_idx
        global gen_por, gen_tr, gen_ise, gen_iae, gen_itae
        global gen_ppor, gen_ptr, gen_pise, gen_piae, gen_pita, Ygen, gen_ptpr 
        num =  np.shape(x)[0]
        por,tpr = obj.overshoot(t,x,num,entries,SP)

    #   calculates the risetime
        
        tr= obj.risetime(t,x,num,entries,SP)
        SSoffset = np.isneginf(por)
        UNSTABLE = np.isnan(por)  
        ISE = obj.ISE(t,x,num,entries,SP)
        IAE = obj.IAE(t,x,num,entries,SP)
        ITAE = obj.ITAE(t,x,num,entries,SP)
        goodpoints = ~(np.isnan(tr)| np.isnan(por)|np.isneginf(por))
        idx = np.arange(0,num)
        tr = tr[goodpoints]
        por = por[goodpoints]
        tpr = tpr[goodpoints]
        ISE = ISE[goodpoints]
        idx = idx[goodpoints]
        
        x = np.array(x)[goodpoints]
        
        p = pareto.domset(map(itemgetter, range(1, 6)), zip(idx, por, tr, ISE, IAE, ITAE))
       
        front = p.data
        idx, ppor, ptr, pise, piae, pitae = map(np.array, zip(*front))
        sortidx = np.argsort(ppor)
        ppor = ppor[sortidx]
        ptpr = tpr[sortidx]
        ptr = ptr[sortidx]
        pise = pise[sortidx]
        piae = piae[sortidx]
        pitae = pitae[sortidx]
        Ygen = x[sortidx]
        
        gen_por, gen_tr, gen_ise, gen_iae, gen_itae = por, tr, ISE, IAE, ITAE
        gen_ppor, gen_ptr, gen_pise, gen_piae, gen_pitae, gen_ptpr = ppor, ptr, pise, piae, pitae, ptpr
        gen_kc_unstable, gen_ti_unstable, gen_td_unstable = kc[UNSTABLE], ti[UNSTABLE], td[UNSTABLE]
        gen_kc_offset, gen_ti_offset, gen_td_offset = kc[SSoffset], ti[SSoffset], td[SSoffset]
        gen_kc_goodpoints, gen_ti_goodpoints, gen_td_goodpoints = kc[goodpoints], ti[goodpoints], td[goodpoints]
        gen_kc_idx, gen_ti_idx, gen_td_idx = kc[idx], ti[idx], td[idx]

    def generate(self,num_of_gens,tfinal, dt, Gp_n, Gp_d, SP, DT,SP_input,step_time,ramp_time):
         global t, entries, u
         gen_count = num_of_gens
         t = np.arange(0, tfinal, dt)
         entries = len(t)
         if gen_count == [0]:
            num = 20          # number of tuning constant sets
            y = np.zeros((entries, num))
            
            # Controller choice
            # Choose controller by typing 'P' , 'PI' or 'PID'
            # Options: 1= P, 2 = PI, 3 = PID
            Contr_type = 'PID'               
            if Contr_type == 'P':
                Controller = 1
            elif Contr_type == 'PI':
                Controller = 2
            elif Contr_type == 'PID':
                Controller = 3
                
            # Random Parameter Generator
            [k_c, t_i, t_d] = func.RPG(num, Controller)     
                                               
            

            # u = func.Ramp(t,ramp_time,SP)
            if SP_input == 'Step':
                u = func.Step(t, step_time, SP)
            else:
                u = func.Ramp(t, ramp_time, SP) 
                
            # Tuning parameters are calculated using external
            # module (Tuners) 
            kczn, tizn, tdzn = ZN(Gp_n, Gp_d, t, u, Contr_type, DT)
            kcch, tich, tdch = Cohen_Coon(Gp_n, Gp_d, t, u, Contr_type, DT)
            
            ## System responce
            for k in range(0, num):
            
                if k == 0:
                    # Inserting Ziegler-Nicholas parameters
                    kc = kczn           
                    ti = tizn
                    td = tdzn
            
                elif k == 1:        
                    # Inserting Cohen-Coon parameters
                    kc = kcch
                    ti = tich
                    td = tdch
                else:
                    kc = k_c[k]
                    ti = t_i[k]
                    td = t_d[k]
            
                if ti == 0:
                    Gc_d = 1
                    Gc_n = [kc * ti * td, (kc * ti), kc]
            
                else:
                    Gc_n = [kc * ti * td, (kc * ti), kc]
                    Gc_d = [ti, 0]
            
                # The process and controller transfer functions are multiplied to make the
                # open loop TF
                OL_TF_n = np.polymul(Gp_n, Gc_n)
                OL_TF_d = np.polymul(Gc_d, Gp_d)
                CL_TF_n = OL_TF_n
                CL_TF_d = np.polyadd(OL_TF_d, OL_TF_n)
                (A, B, C, D) = signal.tf2ss(OL_TF_n, OL_TF_d)
                
                # Open Loop Transfer Function is converted to State Space
                (A_CL, B_CL, C_CL, D_CL) = signal.tf2ss(CL_TF_n, CL_TF_d)
            
                rootsA = np.array(linalg.eigvals(A_CL))
                step_responseEuler = Euler(A, B, C, D, t, u, DT)
                
                # Stabilty of the Closed Loop is checked
                if (rootsA.real < 0).all():
                    for i in range(0, entries):          
                        Y = step_responseEuler
                        y[i, k] = Y[i]
            
                else:
                    y[:, k] = np.NaN
   
                k_c[k] = kc
                t_i[k] = ti
                t_d[k] = td
            
            global kcgen, tigen, tdgen, ygen
            
            kcgen = list(k_c)
            tigen = list(t_i)
            tdgen = list(t_d)
            ygen = list(y.T)

            self.plotter(np.array(kcgen), np.array(tigen), np.array(tdgen), np.array(ygen), num, entries, t, tfinal, dt, SP) 

         if gen_count > [0]:
            num = 20 
            y = np.zeros((entries, num))
            
            Contr_type = 'PID'               
            if Contr_type == 'P':
                Controller = 1
            elif Contr_type == 'PI':
                Controller = 2
            elif Contr_type == 'PID':
                Controller = 3
            
            [k_c, t_i, t_d] = func.RPG(num, Controller)   
            
            for k in range(0, num):
                
                kc = k_c[k]
                ti = t_i[k]
                td = t_d[k]
            
                if ti == 0:
                    Gc_d = 1
                    Gc_n = [kc * ti * td, (kc * ti), kc]
            
                else:
                    Gc_n = [kc * ti * td, (kc * ti), kc]
                    Gc_d = [ti, 0]
            
                OL_TF_n = np.polymul(Gp_n, Gc_n)
                OL_TF_d = np.polymul(Gc_d, Gp_d)
                CL_TF_n = OL_TF_n
                CL_TF_d = np.polyadd(OL_TF_d, OL_TF_n)
                (A, B, C, D) = signal.tf2ss(OL_TF_n, OL_TF_d)

                (A_CL, B_CL, C_CL, D_CL) = signal.tf2ss(CL_TF_n, CL_TF_d)
            
                rootsA = np.array(linalg.eigvals(A_CL))
            
                step_responseEuler = Euler(A, B, C, D, t, u, DT)
            
                if (rootsA.real < 0).all():
                    for i in range(0, entries):
                        Y = step_responseEuler
                        y[i, k] = Y[i]
            
                else:
                    y[:, k] = np.NaN
            
                k_c[k] = kc
                t_i[k] = ti
                t_d[k] = td
                
            kcgen = kcgen + list(k_c)
            tigen = tigen + list(t_i)
            tdgen = tdgen + list(t_d)
            ygen = ygen + list(y.T)

            self.plotter(np.array(kcgen), np.array(tigen), np.array(tdgen), np.array(ygen), num, entries, t, tfinal, dt, SP) 
   
class System_setup_windows(tk.Canvas):
    ''' System_setup_windows was developed to produce a separate window on 
        the Windows operating system.
    '''    
    def __init__(self, master = None):
        tk.Canvas.__init__(self, master, height = 380, width = 500)

        self.grid()
        self.TFnum()
        self.TFden()
        self.Simtime()
        self.Timeinc()
        self.Deadtime()
        self.Setpoint()
        self.Steptime()
        self.Ramptime()
        self.Input()
        self.Ok()
        self.tfinal = 0  
        self.create_text((180, 68), text="Gp(s) num", fill="black")
        self.create_text((180, 98), text="Gp(s) den", fill="black")
        self.create_text((280, 138), text="Simulation Parameters",font=tkFont.Font(weight='bold'))
        self.create_text((50, 168), text="Simulation time(s)", fill="black")
        self.create_text((50, 198),text="Time increment(s)", fill="black")
        self.create_text((40, 228),text="Dead time(s)", fill="black")
        self.create_text((280, 30), text="Process Tranfser function",font=tkFont.Font(weight='bold'))
        self.create_text((350, 168), text="Set Point", fill="black")
        self.create_text((350, 198),text="Step time(s)", fill="black")
        self.create_text((350, 228),text="Ramp time(s)", fill="black")
        self.create_text((350, 275),text="SP input type", fill="black")

    def TFnum(self):
        self.Gpn = tk.Entry(self, width=20, justify=tk.CENTER)
        self.Gpn.place(x=220, y=60)
        self.Gpn.insert(0, "0.125")

    def TFden(self):
        self.Gpd = tk.Entry(self, width=20, justify=tk.CENTER)
        self.Gpd.place(x=220, y=90)
        self.Gpd.insert(0, "1 3 3 1")

    def Simtime(self):
        self.Tsim = tk.Entry(self, width=10, justify=tk.CENTER)
        self.Tsim.place(x=120, y=160)
        self.Tsim.insert(0, "100")

    def Timeinc(self):
        self.Tinc = tk.Entry(self, width=10, justify=tk.CENTER)
        self.Tinc.place(x=120, y=190)
        self.Tinc.insert(0, "0.1")

    def Deadtime(self):
        self. dt = tk.Entry(self, width=10, justify=tk.CENTER)
        self.dt.place(x=120, y=220)
        self.dt.insert(0, "0")

    def Setpoint(self):
        self.sp = tk.Entry(self, width=10, justify=tk.CENTER)
        self.sp.place(x=400, y=160)
        self.sp.insert(0, "1")

    def Steptime(self):
        self.st = tk.Entry(self, width=10, justify=tk.CENTER)
        self.st.place(x=400, y=190)
        self.st.insert(0, "0")

    def Ramptime(self):
        self.rt = tk.Entry(self, width=10, justify=tk.CENTER)
        self.rt.place(x=400, y=220)
        self.rt.insert(0, "10")

    def Get_entries(self):
        global GP_n,Gp_d,tfinal,dt,DT,SP,step_time,ramp_time,SP_input 
        
        Gp_n = [float(s) for s in self.Gpn.get().split()]
        Gp_d = [float(s) for s in self.Gpd.get().split()]
        tfinal = [float(s) for s in self.Tsim.get().split()][0]
        dt = [float(s) for s in self.Tinc.get().split()][0]
        DT = [float(s) for s in self.dt.get().split()][0]
        SP = [float(s) for s in self.sp.get().split()][0]
        step_time = [float(s) for s in self.st.get().split()][0]
        ramp_time = [float(s) for s in self.rt.get().split()][0]
        SP_input = self.inputvar.get()

    def Input(self):
        optionList = ('Step', 'Ramp')
        self.inputvar = tk.StringVar()
        self.inputvar.set(optionList[0])
        self.SPinput = tk.OptionMenu(self, self.inputvar, *optionList)
        self.SPinput.place(x=400, y=260)

    def Ok(self):
        self.okb = tk.Button(
            self, width=10, text='Ok', command=self.Get_entries)
        self.okb.place(x=390, y=350)

class System_setup_linux(tk.Toplevel):
    ''' System_setup_linux was developed to produce a separate window on 
        the Linux operating system.
    '''  
    def __init__(self, master = None):
        tk.Toplevel.__init__(self, master, height = 380, width = 500)
        self.TFnum()
        self.TFden()
        self.Simtime()
        self.Timeinc()
        self.Deadtime()
        self.Setpoint()
        self.Steptime()
        self.Ramptime()
        self.Input()
        self.Ok()
        
        self.text = tk.Label(self, text ="Process Tranfser function",font=tkFont.Font(weight='bold'))
        self.text.place(x=180, y=20)

        self.text = tk.Label(self, text="Simulation Parameters",font=tkFont.Font(weight='bold'))
        self.text.place(x=180, y=120)
        
        self.text = tk.Label(self, text="Gp(s) num")
        self.text.place(x=160, y=60)
        
        self.text = tk.Label(self, text="Gp(s) den")
        self.text.place(x=160, y=90)
        
        self.text = tk.Label(self, text="Simulation time(s)")
        self.text.place(x=10, y=160)
        
        self.text = tk.Label(self, text="Time increment(s)")
        self.text.place(x=10, y=190)
        
        self.text = tk.Label(self, text="Dead time(s)")
        self.text.place(x=10, y=220)
        
        self.text = tk.Label(self, text="Set Point",)
        self.text.place(x=320, y=160)
        
        self.text = tk.Label(self, text="Step time(s)")
        self.text.place(x=320, y=190)
        
        self.text = tk.Label(self, text="Ramp time(s)")
        self.text.place(x=320, y=220)
        
        self.text = tk.Label(self, text="SP input type")
        self.text.place(x=320, y=265)


    def TFnum(self):
        self.Gpn = tk.Entry(self, width=20, justify=tk.CENTER)
        self.Gpn.place(x=220, y=60)
        self.Gpn.insert(0, "0.125")

    def TFden(self):
        self.Gpd = tk.Entry(self, width=20, justify=tk.CENTER)
        self.Gpd.place(x=220, y=90)
        self.Gpd.insert(0, "1 3 3 1")

    def Simtime(self):
        self.Tsim = tk.Entry(self, width=10, justify=tk.CENTER)
        self.Tsim.place(x=120, y=160)
        self.Tsim.insert(0, "100")

    def Timeinc(self):
        self.Tinc = tk.Entry(self, width=10, justify=tk.CENTER)
        self.Tinc.place(x=120, y=190)
        self.Tinc.insert(0, "0.1")

    def Deadtime(self):
        self. dt = tk.Entry(self, width=10, justify=tk.CENTER)
        self.dt.place(x=120, y=220)
        self.dt.insert(0, "0")

    def Setpoint(self):
        self.sp = tk.Entry(self, width=10, justify=tk.CENTER)
        self.sp.place(x=400, y=160)
        self.sp.insert(0, "1")

    def Steptime(self):
        self.st = tk.Entry(self, width=10, justify=tk.CENTER)
        self.st.place(x=400, y=190)
        self.st.insert(0, "0")

    def Ramptime(self):
        self.rt = tk.Entry(self, width=10, justify=tk.CENTER)
        self.rt.place(x=400, y=220)
        self.rt.insert(0, "10")

    def Get_entries(self):
        global GP_n,Gp_d,tfinal,dt,DT,SP,step_time,ramp_time,SP_input 
        
        Gp_n = [float(s) for s in self.Gpn.get().split()]
        Gp_d = [float(s) for s in self.Gpd.get().split()]
        tfinal = [float(s) for s in self.Tsim.get().split()][0]
        dt = [float(s) for s in self.Tinc.get().split()][0]
        DT = [float(s) for s in self.dt.get().split()][0]
        SP = [float(s) for s in self.sp.get().split()][0]
        step_time = [float(s) for s in self.st.get().split()][0]
        ramp_time = [float(s) for s in self.rt.get().split()][0]
        SP_input = self.inputvar.get()

    def Input(self):
        optionList = ('Step', 'Ramp')
        self.inputvar = tk.StringVar()
        self.inputvar.set(optionList[0])
        self.SPinput = tk.OptionMenu(self, self.inputvar, *optionList)
        self.SPinput.place(x=400, y=260)

    def Ok(self):
        self.okb = tk.Button(
            self, width=10, text='Apply', command=self.Get_entries)
        self.okb.place(x=390, y=350)
               
          
############# Buttons #######################
# System change button
def step_window(self):
    OS = platform.system()
    if OS == "Windows":
        wind = System_setup_windows()
    else:
        wind = System_setup_linux()
    wind.master.title('System Specification') 
    wind.mainloop()
     
    return
System = plt.axes([0.25, .92, 0.1, 0.05])
sysbutton = Button(System, 'System Setup')
sysbutton.on_clicked(step_window)

# Point generation
def Point_gen(self):
    Point_generation().generate(num_of_gens, tfinal, dt, Gp_n, Gp_d, SP, DT,SP_input,step_time,ramp_time)
    num_of_gens[0] = num_of_gens[0] + 1
    redraw_ax1()
    redraw_ax2()
    redraw_ax3()
    fig.canvas.draw()


Ppoints = plt.axes([0.125, .92, 0.1, 0.05])
pointbutton = Button(Ppoints, 'Generate')
pointbutton.on_clicked(Point_gen)

# Mopsocd Button
def Opt(self):
    Mop_points[:] = Optimize(tfinal, dt, Gp_n, Gp_d, SP, DT,SP_input,step_time,ramp_time)
    redraw_ax3()
    fig.canvas.draw()

Mopsocd = plt.axes([0.75, .92, 0.1, 0.05])
Mop_button = Button(Mopsocd, 'Mopso-cd')
Mop_button.on_clicked(Opt)


# Objective radio buttons
   # Y axis
rax = plt.axes([0.91, 0.75, 0.07, 0.15])
radio = RadioButtons(rax, ('RT', 'OSR', 'ISE', 'IAE', 'ITAE'))


def colorfunc(label):
    global yobj
    yobj = label
    ax3.cla()
    redraw_ax3()
    plt.draw()

radio.on_clicked(colorfunc)

# X axis
rax2 = plt.axes([0.91, 0.55, 0.07, 0.15])
radio2 = RadioButtons(rax2, ('OSR', 'ISE', 'IAE', 'ITAE', 'RT'))


def colorfunc2(label):
    global xobj
    xobj = label
    ax3.cla()
    redraw_ax3()
    plt.draw()
radio2.on_clicked(colorfunc2)

plt.show()
